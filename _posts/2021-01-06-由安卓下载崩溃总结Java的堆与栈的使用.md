
<details>
  <summary>同僚总结参考</summary>
  
  *#有折叠代码格式可被github检测，但无法在个人主页阅读的问题*
  *#图片加载问题*
![1-1](.../media/pic/tapd_36493192_1609909772_13.png)

在Java开发中，始终绕不过「栈 Stack」与「堆 Heap」的使用问题。

## 栈 Stack 的特性
-栈用于Java程序中「当前正在运行的方法/函数」

- 栈有后进先出的特点，栈中的数据大小与生存期都是确定的，缺乏灵活性

- 栈的存取速度比堆要快，仅次于CPU中的寄存器，另外栈中的数据是共享的

- 栈中的数据生命周期只存在于当前方法的开始与结束，即 { } 花括号内，方法/函数运行结束后栈会被清空（如函数参数值、函数内创建的局部变量）

#### 栈中存储的数据类型：

- 基本类型

- 数据引用（类似于C++中的引用指针，只不过不需要手动管理）

- 方法函数

## 堆 Heap 的特性
- Java中只有一个堆，被所有线程共享

- 堆中的数据没有先后顺序（即一大堆的Object的结构本身的创建没有前后顺序，但Object的创建、引用可以由程序控制）

- 堆中的数据不需要事先告诉编译器它的生存期，可以动态的分配内存的大小（一般看设备的内存空间）

- 堆的存取速度慢，但空间足够

- 堆中不再使用的数据由Java中的垃圾回收机制自动回收（因此也经常会出现无法即时释放内存的问题）

- 在Java中由new创建出来的对象都是在堆中的，当垃圾回收机制检测到某对象未被引用时，则自动销毁该对象

## 对比栈 Stack与堆 Heap
栈Stack	堆Heap	文件File
设备	内存	内存	闪存/硬盘/SD卡
空间	一般几十KB～1MB间	一般512MB～16GB间	一般64GB～1TB间
速度	快	中（可同步操作）	慢（建议异步操作）
灵活度	差	可通过Class定义	JPEG/JSON/文本/任意二进制
## 爆栈原理与程序员文化
由于Java中的栈比较小，所以经常会在各种奇奇怪怪的地方产生爆栈问题，如：

输入的数据过大，如： double x[1048576];

无限递归

递归过深且每个递归都会占用一定数量空间

维基百科关于Stack overflow的解释

由StackOverflow衍生出来的程序员文化：StackOverflow问答社区、各种meme

## 关于由递归引起的StackOverflow问题
由于函数方法本身也被存储于栈 Stack中，所以一般要控制递归的深度。

参考：java.lang.StackOverflowError due to recursion

## 关于安卓版下载程序的递归问题
由于安卓版下载程序每次启动都会把整个下载过的章节列表遍历一遍，并进行递归。这就导致了用户在下载数量较大的书的时候（比如几千个章节），会产生巨大的递归量。

总体来说，结局思路是把本来递归的函数解耦，把Stack里面的数据移到Heap里面，解决方案如下：

## 使用定时器（Timer）来触发章节下载状态的检测
#### 好处
- 定时器本身是一个Object，定时启动并发送事件

- 事件执行时不会产生递归

- 可管理多个进程一起工作

#### 缺点
- 一个下载任务结束时不会非常及时的关闭连接

- 且定时器本身的管理如果写不好，有可能会导致无法正确、及时的创建或关闭其他下载进程

- 有一定可能性会导致费电

## 基于下载事件的分发来触发章节下载状态的检测
#### 好处
- 方法之间只会通过事件方式来触发，事件本身存于Stack中

- 平时只会产生一个下载进程，非常安全

#### 坏处
- 如果想写成多个进程一起下载会很麻烦

</details>

<details>

  <summary>处理方案伪代码</summary>

	
基于定时器的处理方案，好处是可以多thread协作，弊端是不管timer的运行结束状态可能会费电，管timer的开启、关闭可能会增加程序复杂度

new DownloadTimer()

onTimerTrigger()
{  
   遍历当前下载进程数量，及下载状态
   如果下载的线程总数量不超过某个数字（可以留给用户去设置，但要有最大值）则允许新建下载进程
   循环遍历所有章节的下载状态
   如果某个下载结束了，则关闭掉
}


============================


基于下载事件来创建下载进程，弊端是同一时间只能有一个工作。如果在这个逻辑中去写多个进程协作，会很复杂。

onDownloadFinish() {
  sendEvent(DOWNLOAD_CHECK)
}

onDownloadCheck() {
  遍历所有章节下载状态，选一个没下载的开始下载并触发：
  onDownloadStart()
}

onDownloadStart() {
  开始下载逻辑，结束后触发onDownloadFinish()
}
</details>

