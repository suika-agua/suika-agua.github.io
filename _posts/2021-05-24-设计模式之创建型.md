# 设计模式之创建类型

* 单例模式 *（当您想控制实例数目，节省系统资源时）

  **原理：**保证一个类仅有一个实例，并提供一个访问它的全局访问点。

  **实现方式：**  *（对比）*

​				懒汉式 [线程安全/不安全]（获取实例时再初始化）——不建议使用

​				饿汉式（装载时就实例化，线程安全）

​				双检锁/双重校验锁（实例用volatile修饰，获取实例方法加锁synchronized，线程安全）——多线程保持高性能

​				登记式/静态内部类

1. *不用 synchronized ，节省时间。*
2. *调用 getInstance() 的时候才会创建对象，不调用不创建，节省空间，这有点像传说中的懒汉式。*

——明确实现懒加载时使用

​				枚举——设计反序列化创建对象

————————————————————————————————————————

* 原型模式

  （ 1、当一个系统应该独立于它的产品创建，构成和表示时。

  ​	 **2、**当要实例化的类是在运行时刻指定时，例如，通过动态装载。 

  ​	 3、为了避免创建一个与产品类层次平行的工厂类层次时。 

  ​	 **4、**当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。）

  **原理：**用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。

  **实现方式：**实体类（集成于同一基类，基类用clone方法）+工具类（按id/类型名存储于一HashTable，调用工具类实例化指定类）

  *类.clone()

* 工厂模式（我们明确地计划不同条件下创建不同实例时）

  **原理：**定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，在工厂类中实现子类的初始化。

  **实现方式：**实体类（集成于同一基类）+工具类（调用工具类对子类进行初始化）

  **原型模式和工厂模式对比：**原型模式有clone动作，效率更高；子类初始化赋值位置不同；

  **适用范围对比：**（？）

————————————————————————————————————————

* 建造者模式（一些基本部件不会变，而其组合经常变化）

  **原理：**将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。

  **实现方式：**零件装配

* 抽象工厂模式（系统的产品有多于一个的产品族，而系统只消费其中某一族的产品）

  **原理：**提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类

  **建造者模式和抽象工厂模式对比：**建造者模式更加关注与零件装配的顺序

————————————————————————————————————————

* 简单工厂、工厂方法、抽象工厂、Builder模式的区别

  简单工厂模式：一个工厂方法创建不同类型的对象。

  工厂方法模式：一个具体的工厂类负责创建一个具体对象类型。

  抽象工厂模式：一个具体的工厂类负责创建一系列相关的对象。

  Builder模式：对象的构建与表示分离，它更注重对象的创建过程。