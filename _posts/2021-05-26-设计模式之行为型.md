# 设计模式之行为型

* 观察者模式（一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知）

  **目的：**定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。

  **实现方式：**目标对象中绑定所有观察者对象，目标对象发生变化时，依次调用观察者对象的响应方法。

  

* 中介者模式（多个类相互耦合，形成了网状结构）

  **目的：**用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。

  **实现方式：**用一个中介对象来封装一系列的对象交互

  

* 访问者模式（需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作"污染"这些对象的类，使用访问者模式将这些封装到类中。）

  **目的**：将数据结构与数据操作分离。

  **实现方式：**在被访问的类里面加一个对外提供接待访问者的接口

  *（将作用于某数据结构中各元素的操作分离出来封装成独立的类，对这些元素添加新的操作，但不改变原数据结构）*

  

* 状态模式（代码中包含大量与对象状态有关的条件语句）

  **目的：**允许对象在内部状态发生改变时改变它的行为

  **实现方式：**将行为封装在状态类中

  

* 命令模式（需要将"行为请求者"与"行为实现者"解耦，将一组行为抽象为对象，可以实现二者之间的松耦合。）

  **目的：**将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化。

  **实现方式：**将一个请求封装成一个对象

  

* 备忘录模式（额外记录对象某一状态做备份，以便恢复）

  **目的：**在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。

  **实现方式：**构造实体类（包含另存当前状态以及取出给定实体类状态的方法），构造存储多重状态（状态数组）的方法，两者结合以同属存储状态以及状态历史。

  

* 迭代器模式（遍历一个聚合对象）*迭代器原理*

  **目的：**提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。

  **实现方式：**构造迭代器类包含数组（可导入）以及迭代方法hasNext()与next()

  

* 解释器模式（如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子）

  **目的：**给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。

  **实现方式：** *示例代码有误* 

  

* 模板模式（抽象通用方法为模板）

  **目的：**定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即**可重定义**该算法的某些特定步骤。

  **实现方式：** *单纯抽象*



  

  

  

   

  

  

  

  

  

