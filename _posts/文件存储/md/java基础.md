# java

## 面向对象

### 多态

- 条件
- 是什么
- 实现多态技术：动态绑定
- 好处

### 设计模式*

- 设计模式六大原则

	- 单一职责、开放封闭、里式替换、依赖倒置、迪米特、接口隔离

- 创建型

	- 单例，原型，建造者，工厂，抽象工厂

- 结构型

	- 桥接，外观，适配器，代理，组合，装饰，享元

- 行为型

	- 观察者，中介者，访问者，状态，命令，策略，责任链，备忘录，迭代器，解释器，模板方法

- 提问

	- 静态内部类实现单例模式优点
	- 简单工厂、工厂方法、抽象工厂、Builder模式的区别
	- 装饰模式和代理模式有哪些区别 ？与桥接模式相比呢？
	- 外观模式和中介模式的区别

## 集合框架

### 有哪些

- List，Set，Map及特点
- 对比

	- 放入顺序，元素可否重复，增删效率，查找效率，查看方式

### 子类对比

- 线程安全集合

	- Vector,HashTable,ConcurrentHashMap,StringBuffer

- ArrayList&LinkedList
- ArrayList&Vector
- HashSet&TreeSet

	- 哈希表

- HashMap与TreeMap、HashTable
- HashMap 、HashTable、HashSet
- set集合从原理上如何保证不重复
- HashMap和HashTable的主要区别，两者底层实现的数据结构
- HashMap、ConcurrentHashMap、hash()相关原理解析

	- 1.8变化
	- 何时扩容，扩容的算法
	- Hashmap如何解决散列碰撞（冲突）
	- ArrayMap跟SparseArray在HashMap上面的改进*

		- ArrayMap
		- SparseArray

## 反射

### 允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。

### 主要功能

- 判断类，构造类；判断变量、方法，调用方法

## 泛型

### 所操的数据类型被指定为一个参数。这种参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口、泛型方法。

### 好处是在编译的时候检查类型安全，并且所有的转换都是自动和隐式的，提高代码的重用率。

### 要求

- 类型只能是类类型，而非简单类型
- 同一泛型可对象多个版本（参数类型不同），且不同版本泛型不兼容
- 泛型的类型参数可以有多个
- 泛型参数类型可以使用extends语句（？）
- 泛型的参数类型还可以是通配符类型（？）

### 泛型信息仅存在于代码编译阶段，在进入JVM之前，与泛型关的信息都会被擦除掉

## 注解

### 注解相当于一种标记程序可以利用ava的反射机制来了解你的类及各种元素上有无何种标记，针对不同的标记，就去做相应的事件。

## 其他

### final关键字

- 修饰类，表明这个类不能被继承；修饰方法，一为防止继承类（子类）重写此方法，二为提高效率（已失效）；修饰变量，如果是基本数据变量，则初始化之后不能再改，如果是应用类型变量，则不能再指向另一个对象。

### static关键字

- static方法，指静态方法，不依赖于任何对象即可访问；static变量，指静态变量， 其被所有对象共享，内存中只有一个副本，仅在初次加载时会被初始化；static代码块，类初次加载时执行且仅执行一次，用于优化程序性能。

### 

### 11、抽象类和接口的区别

- 共同点

	- 不能被实例化
	- 都是上层的抽象层
	- 都能包含抽象的方法，这些抽象的方法用于描述类具备的功能，但是不提供具体的实现
	- 派生类必须实现未实现的方法

- 不同

	- 抽象类可写非抽象方法，接口只能有抽象方法
	- 一个类只能议程一个父类，但可以实现多个接口
	- 抽象类中的方法可以有默认实现
	- 抽象类可有构造器，接口无构造器
	- 抽象类除不能实例化以外，和其他类没有任何不同
	- 抽象类方法可有修饰符，接口方法只能是public
	- 抽象类比接口速度快

- 一个类可以继承多个接口，只能继承一个类

### 14、抽象类的意义

- 封装重复内容，定义抽象方法

### 1、2、字符存储空间相关*

### 3、匿名内部类

- 定义时仅用类初始化方式定义
- 只能继承一个父类或者实现一个接口
- 只能捕获外部作用于内的final变量(1.8以前)

	- 7、为什么Java里的匿名内部类只能访问final修饰的外部变量

		- 因为匿名内部类最终会编译成一个单独的类，而被该类使用的变量会以构造函数参数的形式传递给该类，不定义为final，则可在匿名内部类中被修改

	- Error是程序无法处理的错误，会引起线程终止；Exception是程序本身可处理异常，可捕获处理也可不处理，不会引起线程终止。

- 匿名内部类中不能定义静态属性、方法
- 与内嵌类相同，会屏蔽同名变量，优先调用内部变量（变量名前加上父类名，可调用其他作用于范围的同名变量/方法）

### 15、静态内部类、非静态内部类*

- 静态内部类只是为了方便管理类结构而定义，费静态内部类持有外部类的引用，可自由使用外部类的变量和方法

### 21、静态内部类的设计意图

- 非静态内部类在编译完成之后会隐含一个引用指向它的外围类，静态内部类没有，意味着静态内部类是不需要依赖于外围类的，他不能使用任何外围类的非static成员变量和方法

### 23、静态属性和静态方法是否可被继承与重写

- 可以被继承，但不能被重写而是被隐藏
- 原因

	- 静态方法属于类，不需要继承机制即可调用，子类定义同名方法和属性，则隐藏父类方法或属性
	- 重写后子类的优先级高于父类，但隐藏没有这个优先级之分
	- 静态属性。方法，非静态属性都可以被继承和隐藏而不是重写，因此不能实现多态。非静态方法可以实现多态

### 4、异常分类

- NoClassDefFoundError 和 ClassNotFoundException 有什么区别

	- 子主题 1

		- ncdf-加载类的时候却找不到类的定义
		- cnf-通过反射动态加载类时没有找到指定类

### 5、String为什么要设计成不可变的

- String本质上是个final的char[]数组，不可变性可以保证线程安全以及字符串常量池的实现。
- 字符串常量池：为字符串开辟一个字符串常量池，类似于缓存区/创建字符串常量时，首先坚持字符串常量池是否存在该字符串、存在该字符串，返回引用实例，不存在，实例化该字符串并放入池中

### 6、Java里的幂等性

- 一连串步骤中，使用Token机制，一个token在操作的每一阶段只有一次执行权，一旦执行成功则保存执行结果，重复请求返回同一结果。（电商平台下单：比如生成订单，减库存，减优惠券）

### 8、Java的编码方式

- ASCII
- GBK
- UTF-16
- UTF-8

### 9、String，StringBuffer，StringBuilder不同

- 执行速度：StringBuilder >  StringBuffer  >  String
- 操作量少但执行效率低：String
- StringBuilder线程不安全；StringBuffer线程安全
- 单线程操作字符串缓冲区下操作大量数据：StringBuilder
- 多线程操作字符串缓冲区下操作大量数据：StringBuffer

### 10、内部类

- 内部类可有多个实例
- 多个内部类可实现同一个接口，或继承同一个类
- 创建内部对象不依赖于外围对象的创建^
- 内部类除了外围类，其他类都不能访问

### 12、接口的意义：规范、拓展、回调

### 13、父类的静态方法不能被子类重写

### 16、为什么复写equals方法时需要复写hashcode方法

- equals中用==进行比较，若非基本数据类型，则比较在内存中的地址
- hashCode返回当前对象的哈希散列码，补充协议
- https://blog.csdn.net/weixin_38869158/article/details/107557257

### 17、equals和hashcode的关系

- 如果两个对象相等，则他们一定有相同的哈希值
- 如果两个对象的哈希值相等，那么这两个对象有可能不相等

### 29、重写equals方法时遵循规定

- 自反性

	- x.equals(x)且x!=null 必须返回true

- 对称性

	- x.equals(y)为true时，y.equals(x)也为true

- 传递性

	- x.equals(y)==true,y.equals(z)==true,那么x.equals(z)==true

- 一致性

	- 多次调用，结果不变

- 非空性

	- 子主题 1

### 18、Java为什么跨平台

- Java程序编译之后带把不是能被硬件系统直接运行的代码，而是字节码，由不同硬件平台上安装的JVM翻译成硬件平台能执行的代码

### 20、final、finally、finalize的区别

- 修饰词，修饰class为不可继承拓展，修饰变量为必可修改，修饰方法为不可重写
- finally是保证重点代码一定要被执行的机制，用于try-finally,try-catch-finally，来进行类似关闭JDBC连接，保证unlock锁等动作
- finalize被用于保证对象在被垃圾收集前完成特定资源的回收，现已不推荐使用

### 22、Java对象的生命周期

- 创建阶段

	- JVM加载class文件（加载static变量和static方法）->对局部变量赋值（先夫后子）->执行new方法->调用构造函数

- 应用阶段

	- 对象至少被一个强引用持有

- 不可见阶段

	- 程序不再持有该对象强引用，程序执行已超出了对象作用域。引用仍可能存在

- 不可达阶段

	- 该对象不再被任何强引用所持有

- 收集阶段

	- 垃圾回收器已经对该对象的内存空间重新分配做好准备时，此时会执行finalize()方法

- 终结阶段

	- 执行完finalize()之后，继续等待回收

- 对象空间重分配阶段

	- 垃圾回收器对该对象的所占用的内存空间进行回收或者再分配

### 26、Java的四种引用及使用场景

- 强引用（FinalReference）：在内存不足时不会被回收。平常用的最多的对象，如新创建的对象。
- 软引用（SoftReference）:在内存不足时会被回收，用于实现内存敏感的高速缓存
- 弱引用（WeakReference）：只要GC回收器发现了他，就会将之回收。用于Map数据结构中，引用占用内存较大的对象
- 虚引用（PhantomReference）:在回收之前，会被放入ReferenceQueue，JVM不会自动将该Referent字段值设为null。其他引用被JVM回收之后才会被放入ReferenceQueue中。用于实现一个对象被回收之前的做一些清理工作。

	- 你可以通过判断queue里面是不是有对象来判断你的对象是不是要被回收了

### 27、类的加载过程（Person person = new Person()）

- 先找到Person.class文件，并加载到内存中
- 执行该类中static代码块，给Persion.class类进行初始化
- 在堆内存中开辟空间分配内存地址
- 在堆内存中简历对象的特有属性，并进行默认初始化
- 对属性进行初始化
- 对对象进行构造代码块初始化
- 对对象进行与之对应的都在函数进行初始化
- 将内存地址付给栈内存中的p变量

### 28、整型常量池

- 范围为（-128-127）时，分开初始化对象[==]比较为false，赋值得到对象[==]比较为true
- 不在指定范围中[==]比较范围都为false
- Integer和int同理
- 存储位置：Integer类中有一个静态内部类IntegerCache

### 30、深拷贝和浅拷贝的区别*

### 31、Integer对int的优化

### 32、IO、NIO、OKIO

- IO面向流，一次处理一个字节；NIO面向缓冲区，一次产生/消费一个数据块
- IO是阻塞的，NIO是非阻塞的
- NIO支持内存映射
- OKIO最简单易用
- OKIO支持超时机制
- OKIO性能更好
- OKIO采用segment机制进行内存共享，节省copy时间消耗

### 

### 

### 

## 子主题 1

*XMind - Trial Version*